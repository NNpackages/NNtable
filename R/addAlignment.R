#' Add alignment specifications to an .NNTable
#'
#' @param .NNTable An \code{NNTable} generated by \code{\link{NNTable}}
#' @param ... The alignment specification. It can be specified as: some_col1 =
#'   "c", "some with col2" = "l", some_col3 = "r", where some_col1, "some with
#'   col2", and some_col3 corresponds to the column names in the original data.
#'   When used together with \code{link{addTranLong}} the created column names
#'   need to be used.
#'
#' @return An object of class \code{NNTable} with the formatting applied
#' @export
#' @examples
#'
#' ## *****************************************************************************
#' ## # Example of transpose from wide to long                                 ----
#' ##
#' ## Calculate the statistics for an AE table
#' ## *****************************************************************************
#'
#' library(dplyr)
#' # library(NNR)
#'
#' # Filter data according Safety analysis set
#' adsl_f <- adsl            %>%
#'   filter(SAFFL == "Y")    %>%
#'     rename(TRTA = TRT01P)
#'
#' # Calculate total exposure
#' totals <- adsl_f        %>%
#'   group_by(TRTA)        %>%
#'   summarize("Number of subjects"     = n_distinct(USUBJID),
#'             "Total exposure (years)" = sum(TR01DURY))
#'
#' # Calculate adverse event statistics
#' output <- adae %>% group_by(AEBODSYS, AEDECOD, TRTA) %>%
#'   dplyr::summarise(N = n_distinct(USUBJID),
#'                    P = N / nrow(adsl),
#'                    E = n())
#'
#' # Generate the NNTable ------------------------------------------------------
#'
#' # Initiate by defining the columns based on ADAE
#' .NNTable <- NNTable(output, "AEBODSYS", "AEDECOD", "TRTA", "N", "(%)" = "(P)", "E")
#'
#' # Add exposure calculated from ADSL
#' .NNTable <- .NNTable %>%
#'   addExposure(exposure = totals,
#'               format_alone = FALSE,
#'               format_data  = c("Number of subjects"     = "%.0f",
#'                                "Total exposure (years)" = "%.2f"))
#'
#' # Test alignment
#' .NNTable <- .NNTable %>% addAlignment(AEDECOD = "c", AEBODSYS = "r")
#'
#' # print the table
#' .NNTable
addAlignment <- function(.NNTable, ...) {
  .NNTable$alignment <- list(alignment_specified = c(...))

  return(.NNTable)

}


apply_alignment <- function(.NNTable) {

  if (is.null(.NNTable$alignment)) {
    .NNTable$alignment <- list()
  }

  # get size of header
  n.header.rows <- nrow(.NNTable$header$matrix)


  data <- .NNTable$data
  data_str <- .NNTable$data_str[, setdiff(colnames(.NNTable$data_str),
                                          c(.NNTable$remove$columns, .NNTable$remove$columns_trunc)), drop = FALSE]

  ncol <- ncol(data_str)

  header <- colnames(data_str)

  alignment = c("l", rep("c", max(0, ncol - 2)), "c")[seq_len(ncol)]

  # give names to the alignment
  names(alignment) <- colnames(data_str)

  # make sure that the characters are left aligned

  classes <- sapply(data, class)
  classes_str <- sapply(data_str, class)

  # for columns that are transposed from wide to long the name column is left aligned
  # as well as combination columns
  if (!is.null(.NNTable$columns_to_long) && length((.NNTable$columns_to_long))) {
    classes <- c(classes, structure("character", names = .NNTable$columns_to_long$var_name))

    # Check if any columns are concatinated
    if (length(setdiff(initName(.NNTable$columns_to_long$columns), colnames(data)))) {
      alignment[grep(paste0("^", .NNTable$columns_to_long$value_name), colnames(data_str))] <- "l"
    }
  }

  # Add the grouped name
  if (!is.null(.NNTable$grouped_columns)) {
    classes <- c(classes, structure("character", names = "NNTable_grouped_name"))
  }

  # if not numeric the columns are left aligned
  alignment[names(classes[!classes %in% c("numeric", "integer") & names(classes) %in% header])] <- "l"
  # in case the header is not a part of the original columns we make them left aligned
  alignment[header[!header %in% names(classes) & !grepl("^sep.column.", header)]] <- "l"


  numerics <- names(classes[classes %in% c("numeric", "integer")])

  # some columns are renamed which needs to be taken into account
  # names_conv <- unlist(.NNTable$concat$table[sapply(.NNTable$concat$table, length) == 1])
  # to_numeric <- names_conv[match(numerics, names_conv)]
  # alignment[names(to_numeric)[names(to_numeric) %in% header]] <- "c"

  names_conv <- names(.NNTable$concat$table[sapply(.NNTable$concat$table, function(x) {all( x %in% numerics)})])
  alignment[names_conv[names_conv %in% header | paste0(names_conv, "_trunc") %in% header]] <- "c"

  # columns that are really short should be centred
  small <- sapply(data_str[classes_str == "character"], function(x) max(nchar(x,  keepNA = FALSE))) <= 4
  alignment[names(small)[small]] <- "c"

  # something seems odd here
  if (!is.null(.NNTable$columns_to_long) && length((.NNTable$columns_to_long))) {

    # extract the variables
    vars <- initName(.NNTable$columns_to_long$columns)

    # if all columns are numerical we centre the created column
    # this is taken out again since we want the values to be left aligned
    #if (all(vars %in% names_conv))
    #  alignment[.NNTable$columns_to_long$value_name[.NNTable$columns_to_long$value_name %in% header]] <- "c"


    cols <- intersect(vars, names(classes))
    if (length(cols) && !any(classes[cols] %in% c("numeric", "integer"))) {

      list <- strsplit(gsub("NNTable_grouped_name", "" , colnames(data_str)), "__#__")
      cols <- sapply(list, function(x) rev(c(x, rep("", n.header.rows - length(x)))))
      if (is.matrix(cols)) {
        which <- apply(cols == .NNTable$columns_to_long$value_name, 2, any)
      } else {
        which <- cols == .NNTable$columns_to_long$value_name
      }
      alignment[which] <- "l"
    }
  }

  if (!is.null(.NNTable$alignment$alignment_specified)) {


    if (!is.null(.NNTable$grouped_columns)) {
      list <- strsplit(gsub("NNTable_grouped_name", .NNTable$grouped_columns$name,
                            gsub("_trunc$", "", names(alignment))), "__#__")
    } else {
      list <- strsplit(gsub("_trunc$", "", names(alignment)), "__#__")
    }


    l_depth <- max(sapply(list, length))
    cols <- sapply(list, function(x) rev(c(x, rep("", l_depth - length(x)))))
    if (is.matrix(cols)) {
      for (name in names(.NNTable$alignment$alignment_specified)) {
        alignment[apply(cols == name, 2, any)] <-
          .NNTable$alignment$alignment_specified[name]
      }
    } else {
      for (name in names(.NNTable$alignment$alignment_specified)) {
        alignment[cols == name] <- .NNTable$alignment$alignment_specified[name]
      }
      #which <- cols == .NNTable$columns_to_long$value_name
    }
  }

  .NNTable$alignment <- list(alignment = alignment)
  return(.NNTable)
}

#' Center text in monospaced output
#'
#' @param text \code{character} to center
#' @param width the number of characters of the column
#' @param type should text be trimmed or not
#' @param fill Should trailing blanks be added
#' @param keep.empty should completely empty comlumns be left blank
#'
#' @return The \code{character} \code{text} with added spaced in front
#' @keywords internal
alignCenter <- function(text, width = max(nchar(text)),
                        type = c("non-trimmed", "trimmed"),
                        fill = TRUE,
                        keep.empty = TRUE) {
  textWidth <- nchar(text)
  spare <- width - textWidth
  nspaces   <- pmax(ceiling(spare/2), 0)

  spaces    <- sapply(nspaces, function(n) paste(rep(" ", n), collapse = ""))
  if (fill) {

    spaces.trail <-
      sapply(pmax(width - textWidth - nspaces, 0), function(n) paste(rep(" ", n), collapse = ""))
  } else {
    spaces.trail <- ""
  }

  c.text    <- paste(spaces, text, spaces.trail, sep = "")

  if (keep.empty) {
    c.text[textWidth == 0] <- ""
  }

  return(c.text)
}

#' Add space on left for monospaced output
#'
#' @param text \code{character} to center
#' @param width the number of characters of the column
#' @param type should text be trimmed or not
#' @param keep.empty should completely empty comlumns be left blank
#'
#' @return The \code{character} \code{text} wtihout leading and trailing blanks
#' @keywords internal
alignRight <- function(text, width = max(nchar(text)), type = c("non-trimmed", "trimmed"), keep.empty = TRUE) {
  textWidth <- nchar(text)
  nspaces   <- floor((width - textWidth))
  spaces    <- sapply(nspaces, function(n) paste(rep(" ", n), collapse = ""))
  l.text    <- paste(spaces, text, sep = "")

  if (keep.empty) {
    l.text[textWidth == 0] <- ""
  }

  return(l.text)
}

#' Add space on right for monospaced output
#'
#' @param text \code{character} to center
#' @param width the number of characters of the column
#' @param type should text be trimmed or not
#' @param sep The inserted space generator, defaults to " ".
#' @param keep.empty should completely empty comlumns be left blank
#'
#' @return The \code{character} \code{text} wtihout leading and trailing blanks
#' @keywords internal
alignLeft <- function(text, width = max(nchar(text)),
                      type = c("non-trimmed", "trimmed"),
                      sep = " ",
                      keep.empty = TRUE) {
  textWidth <- nchar(text, keepNA = FALSE)
  nspaces   <- floor((width - textWidth))
  spaces    <- sapply(nspaces, function(n) paste(rep(sep, n), collapse = ""))
  r.text    <- paste(text, spaces, sep = "")

  if (keep.empty) {
    r.text[textWidth == 0] <- ""
  }

  return(r.text)
}

#' Align text in monospaced output
#'
#' @param x \code{character} to center
#' @param width the number of characters of the column
#' @param type should text be trimmed or not
#' @param alignment the type of alignment.
#' @param keep.empty should completely empty comlumns be left blank
#'
#' @return The \code{character} \code{x} with added spaces
#' @export
align <- function(x, alignment = c("left", "center", "right"),
                  width = max(nchar(text)),
                  type = c("non-trimmed", "trimmed"),
                  keep.empty = TRUE) {

  x <- as.character(x)
  x[is.na(x)] <- ""
  alignment <- match.arg(alignment)
  type      <- match.arg(type)

  text      <- switch(type,
                      trimmed  = trimws(x),
                      x)

  if (alignment == "left")
    return(alignLeft(text, width, type, keep.empty = keep.empty))

  if (alignment == "center")
    return(alignCenter(text, width, type, keep.empty = keep.empty))

  if (alignment == "right")
    return(alignRight(text, width, type, keep.empty = keep.empty))
}

