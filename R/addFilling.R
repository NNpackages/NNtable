#' Add filling to an NNTable
#'
#' @param .NNTable An \code{NNTable} generated by
#'   \code{\link{NNTable}}
#' @param ... Named elements where the name is the column and value is the
#'   inserted value
#' @param by \code{character} defining the columns the fillings should be added
#'   in accordance to. Missing combinations of the by columns will be added for
#'   the columns defined in \code{columns}.
#'
#' @return An object of class \code{NNTable} with the filling specified
#' @export
#' @examples
#'
#' ## *****************************************************************************
#' ## # Example of transpose from wide to long                                 ----
#' ##
#' ## Calculate the statistics for an AE table
#' ## *****************************************************************************
#'
#' library(dplyr)
#' # library(NNR)
#'
#' # Filter data according Safety analysis set
#' adsl_f <- adsl            %>%
#'   filter(SAFFL == "Y")    %>%
#'     rename(TRTA = TRT01P)
#'
#' # Calculate total exposure
#' totals <- adsl_f        %>%
#'   group_by(TRTA)        %>%
#'   summarize("Number of subjects"     = n_distinct(USUBJID),
#'             "Total exposure (years)" = sum(TR01DURY))
#'
#' # Calculate adverse event statistics
#' output <- adae %>% group_by(AEBODSYS, AEDECOD, TRTA) %>%
#'   dplyr::summarise(N = n_distinct(USUBJID),
#'                    P = N / nrow(adsl),
#'                    E = n())
#'
#' # Generate the NNTable ------------------------------------------------------
#'
#' # Initiate by defining the columns based on ADAE
#' .NNTable <- NNTable(output, "AEBODSYS", "AEDECOD", "TRTA", "N", "(%)" = "(P)", "E")
#'
#' # Add exposure calculated from ADSL
#' .NNTable <- .NNTable %>%
#'   addExposure(exposure = totals,
#'               format_alone = FALSE,
#'               format_data  = c("Number of subjects"     = "%.0f",
#'                                "Total exposure (years)" = "%.2f"))
#'
#' # Transpose to wide
#' .NNTable <- .NNTable %>% addTransWide(TRTA = c("N", "(%)", "E"))
#'
#' # Add Filling such that non-observed events is assigned 0
#' .NNTable <- .NNTable %>% addFilling(N = 0)
#'
#' # Add formatting information for the table
#' .NNTable <- .NNTable %>% addFormat(format_data = c(N = "%.0f", P = "%.2f", E = "%.0f"))
#'
#' # Group the columns AEBODSYS and AEDECOD
#' .NNTable <- .NNTable %>% addGroupedColumns("AEBODSYS", "AEDECOD" , name = "some name")
#'
#' # Truncate columns at a certain width such that long names appear on multiple lines
#' .NNTable <- .NNTable %>% addTruncation(AEBODSYS = 50, AEDECOD = 48)
#'
#' # View the final result
#' .NNTable
addFilling <- function(.NNTable, ..., by = NULL) {

  .NNTable$filling <- list(columns = c(...), by = by)

  return(.NNTable)
}



#' Add values for colums that are not present in data
#'
#' @param .NNTable An \code{NNTable} generated by \code{\link{NNTable}}
#'
#' @importFrom glue glue_data
#' @importFrom tidyr separate
#' @keywords internal
apply_filling <- function(.NNTable) {

  data_str <-  .NNTable$data_str

  filling <- .NNTable$filling

  # because we might have nested columns we make sure that original col names
  # are matched to the new col names
  missing_names <- setdiff(names(filling$columns),
                           names(.NNTable$columns))
  if (length(missing_names))
    names(filling$columns)[match(missing_names, names(filling$columns))] <-
    names(.NNTable$columns)[match(missing_names, .NNTable$columns)]

  # Find columns that are not nested
  left_over <- unlist(sapply(names(.NNTable$tree$tree), function(name) {
    x <- .NNTable$tree$tree[[name]]
    if (is.atomic(x) && length(x) == 1 && name == x)
      return(x)
  }))

  left_over_columns <- .NNTable$columns[names(left_over)]
  #left_over_columns <- .NNTable$columns[left_over]

  classes <- sapply(data_str, class)

  by_temp <- names(classes)[classes %in% c("factor", "character")]

  sort_cols <- .NNTable$order_columns$sort_columns[
    .NNTable$order_columns$sort_columns %in% colnames(data_str)]
  stable <- unique(c(intersect(left_over_columns, by_temp), sort_cols))

  # The total column is added to make sure that this group will not be formatted
  # completely alone
  if ("NNTable_mj_order" %in% colnames(data_str))
    stable <- c(stable, "NNTable_mj_order")

  if (is.null(filling$by)) {

    tree_columns <- sapply(.NNTable$tree$tree, get_unlist_vars)

    grow_tree <- function(tree = tree_columns,
                          column_tree = .NNTable$columns_attr$columns_tree) {

      for (name in names(tree)) {
        tree[[name]] <- structure(unlist(column_tree[tree[[name]]]), names = NULL)
      }
      tree
    }


    tree_columns <- grow_tree()


    where <- sapply(tree_columns, function(x) any(names(filling$columns) %in% x))
    if (names(where[where]) %in% names(.NNTable$columns_to_wide$columns)) {
      nestings <- get_unlist_names_only(x = .NNTable$columns_to_wide$columns)

      if (!is.null(.NNTable$columns_to_long$columns)) {
        nestings <- setdiff(nestings, names(.NNTable$columns_to_long$columns))
      }

      by <- c(stable, intersect(.NNTable$columns[nestings], by_temp))
    } else {
      by = stable
    }
  } else {
    by <- filling$by
  }


  # to avoid getting many null columns the stable vars are pasted together and
  # replaced in the by
  stable_in_by <- intersect(stable, by)

  data_str <- data.table::as.data.table(data_str)

  if (length(stable_in_by)) {


    to_char <- intersect(stable_in_by,
                         colnames(.NNTable$data_str)[sapply(.NNTable$data_str, is.character)])

    if (length(to_char))
      data_str[, (to_char) := lapply(.SD,
                                     function(x) {x[is.na(x)] <- "NA_replace_me"; x}), .SDcols = to_char]

    to_factor <- intersect(stable_in_by,
                           colnames(.NNTable$data_str)[sapply(.NNTable$data_str, is.factor)])

    if (length(to_factor))
      data_str[, (to_factor) := lapply(.SD,
                                       function(x) {levels(x) <- c(levels(x), "NA_replace_me"); x[is.na(x)] <- "NA_replace_me"; x}), .SDcols = to_factor]

    data_str$stable_filling <-
      glue::glue_data(data_str, paste0("{", paste(stable_in_by, collapse = "}__#_#_#__{"), "}"))

    by <- c(setdiff(by, stable), "stable_filling")

  }


  completeDT <- function(DT, cols, defs = NULL){
    mDT = do.call(data.table::CJ, c(DT[, cols, with = FALSE], list(unique = TRUE)))
    res = DT[mDT, on = names(mDT)]
    if (length(defs))
      res[, names(defs) := Map(replace, .SD, lapply(.SD, is.na), defs), .SDcols = names(defs)]
    res[]
  }


  names(filling$columns) <- .NNTable$columns[names(filling$columns)]

  if (!all(names(filling$columns) %in% colnames(data_str))) {
    rest <- setdiff(colnames(data_str),  c(.NNTable$columns, "stable_filling"))
    rest <- rest[order(nchar(rest), decreasing = TRUE)]
    missing <- setdiff(names(filling$columns), colnames(data_str))
    for (weird in missing) {
      for (column in rest) {
        if (grepl(column, weird) && weird %in% missing){
          rest <- setdiff(rest, column)
          missing <- setdiff(missing, weird)
          names(filling$columns)[names(filling$columns) == weird] <- column
        }
      }
    }
    still_missing <- setdiff(names(filling$columns), colnames(data_str))
    if (length(still_missing))
      warning(paste("I could not find column(s)", paste(still_missing, collapse = ", "), "when adding Filling"))
  }


  data_str_old <- data_str
  data_str <- completeDT(DT = data_str, cols =  by, defs = filling$columns[names(filling$columns) %in% colnames(data_str)])

  # in case all used to be NA for exposure data we do not want to add a row to it
  # So we replace the values with zero
  if ("NNTable_mj_order" %in% colnames(data_str)) {
    data_str_exp <- data_str_old[data_str_old$NNTable_mj_order == 0]
    for (col in names(filling$columns[names(filling$columns) %in% colnames(data_str)]))
      if (all(is.na(data_str_exp[[col]])))
        data_str[data_str$NNTable_mj_order == 0, (col) := NA]
  }

  if (!is.null(.NNTable$order_columns$sort_columns) &
      any(.NNTable$order_columns$sort_columns %in% colnames(data_str) &
          !.NNTable$order_columns$sort_columns %in% left_over_columns)) {

    cols <- .NNTable$order_columns$sort_columns[.NNTable$order_columns$sort_columns %in% colnames(data_str) &
                                                  !.NNTable$order_columns$sort_columns %in% left_over_columns]

    orders <- data_str[, lapply(.SD, min, na.rm = TRUE), "stable_filling", .SDcols = cols]

    data_str[, (cols) := NULL]
    names(stable) = NULL
    data_str <- data_str[orders, on = "stable_filling"]
  }

  if ("stable_filling" %in% colnames(data_str)) {

    a <-  tidyr::separate(data_str[, "stable_filling", drop = FALSE],
                          col = .data$stable_filling, sep = "__#_#_#__",
                          remove = FALSE, fill = "right",
                          into = stable_in_by)

    data_str[, c("stable_filling", stable_in_by) := a]

    data_str <- data_str[, "stable_filling" := NULL]

    # replace the inserted NAs
    if (length(to_char))
      data_str[, (to_char) := lapply(.SD,
                                     function(x) {x[x == "NA_replace_me"] <- NA; x}), .SDcols = to_char]


    if (length(to_factor))
      data_str[, (to_factor) := lapply(.SD,
                                       function(x) {x[x == "NA_replace_me"] <- NA; x}), .SDcols = to_factor]

    to_num <- intersect(stable_in_by,
                        colnames(.NNTable$data_str)[sapply(.NNTable$data_str, is.numeric)])

    if (length(to_num))
      data_str <-
      data_str[,  (to_num) := lapply(.SD, as.numeric), .SDcols = to_num]

  }

  # convert factors back into factors in order to preserve ordering
  classes_orig <- sapply(.NNTable$data_str[stable_in_by], class)
  if (any(classes_orig == "factor"))
    for (fac in names(classes_orig[classes_orig == "factor"]))
      data_str[, fac] <- factor(data_str[[fac]], levels(.NNTable$data_str[[fac]]))



  .NNTable$data_str <- as.data.frame(data_str)
  return(.NNTable)
}
