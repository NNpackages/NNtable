#' Add formatting info to an NNTable
#'
#' @param .NNTable An \code{NNTable} generated by \code{\link{NNTable}}
#' @param dec \code{integer} defining the number of decimals to use
#' @param format_data \code{data.frame} containing a set of formats. The column
#'   names of the supplied data to \code{\link{NNTable}} will be matched to the
#'   column names of \code{format_data}.
#' @param big.mark \code{character} for thousands Separator
#' @param small.mark \code{character} for Separating each fifth decimal
#' @param ... Additional arguments, not currently supported
#' @param group_by \code{character} with golumns indicating groups by which the
#'   format is calculated individually
#'
#' @return An object of class \code{NNTable} with the formatting applied
#' @export
#' @examples
#' ## *****************************************************************************
#' ## # Calculate summary statistics                                           ----
#' ##
#' ## The exposure/summary statistics are calculated for ADSL and ADLB
#' ## *****************************************************************************
#'
#' # filter and rename adsl to get totals
#' # library(NNR)
#' library(dplyr)
#'
#' adsl_f <- adsl       %>%
#' filter(FASFL == "Y") %>%
#'   rename(TRTP = TRT01P)
#'
#' # calculate the totals by treatment arm
#' totals <- adsl_f         %>%
#'   mutate(TRTP = "Total") %>%
#'   bind_rows(adsl_f)      %>%
#'   filter(FASFL == "Y")   %>%
#'   group_by(TRTP)         %>%
#'   summarize("Number of subjects"     = n_distinct(USUBJID),
#'             "Total exposure (years)" = sum(TR01DURY))
#'
#' # Calculate the summary statistcs
#' output <- adlb                                                  %>%
#'   mutate(TRTP = "Total")                                        %>%
#'   bind_rows(adlb)                                               %>%
#'   filter(SAFFL == "Y" & PARAMCD %in% c("ABSR148N", "ABTIT148")) %>%
#'   group_by(TRTP, PARAM, STUDYID)                                %>%
#'   summarize(N  = n_distinct(USUBJID),
#'             Mean = mean(AVAL, na.rm = TRUE),
#'             SD   = sd(  AVAL, na.rm = TRUE),
#'             Min  = min( AVAL, na.rm = TRUE),
#'             Max  = max( AVAL, na.rm = TRUE)
#'   )
#'
#' # The NNTable is generated in small steps to view what happens
#'
#' # Initiate the table
#' .NNTable <- NNTable(output, "PARAM", "TRTP", "N", "Mean (SD)", "Min ; Max")
#'
#' # View the table
#' .NNTable
#'
#'
#' # Transpose the summary columns to long format
#' .NNTable <- .NNTable                                    %>%
#'   addTransLong(SUM = c("N", "Mean (SD)" , "Min ; Max"),
#'                var_name = "Called var")                 %>%
#'   addFormat(format_data = c(N = "%.0f"), dec = 2)
#'
#' # View the table
#' .NNTable
#'
#' # Add exposure, transpose to wide and ad grouping variables
#' .NNTable <- addExposure(.NNTable, exposure = totals,
#'                         format_alone = TRUE,
#'                         format_data  = c("Number of subjects" = "%.0f")) %>%
#'             addTransWide(TRTP = "SUM")                                   %>%
#'             addGroupedColumns("PARAM", "Called var")
#'
#' # View the final result
#' .NNTable
addFormat <- function(.NNTable, dec = 3, format_data = NULL,
                      big.mark = "", small.mark = "", group_by = NULL, ...) {

  if (!is.null(format_data)) {
    if (!is.data.frame(format_data)) {
      format_data <- as.data.frame(t(format_data), )
    }
    factors <- sapply(format_data, is.factor)
    if (length(factors))
      format_data[, factors] <- lapply(format_data[, factors], as.character)

    matrix(ncol = ncol(format_data))
  }

  .NNTable$NNFormat <- list(dec         = dec,
                            format_data = format_data,
                            big.mark    = big.mark,
                            small.mark  = small.mark,
                            group_by    = group_by)

  return(.NNTable)
}

apply_create_format_data <- function(.NNTable) {

  if (!"NNFormat" %in% names(.NNTable)) {

    .NNTable <- Format(.NNTable)

  } else {

    .NNTable <- Format(.NNTable,
                       dec         = .NNTable$NNFormat$dec,
                       format_data = .NNTable$NNFormat$format_data,
                       big.mark    = .NNTable$NNFormat$big.mark,
                       small.mark  = .NNTable$NNFormat$small.mark,
                       group_by    = .NNTable$NNFormat$group_by)

  }

  return(.NNTable)
}



#' Apply specified format and concatenate columns
#'
#' @param .NNTable An \code{NNTable} generated by \code{\link{NNTable}}
#'
#' @importFrom stringr str_glue_data
#' @keywords internal
apply_format_concat <- function(.NNTable) {
  .NNTable$columns

  data_str <- data.table::as.data.table(.NNTable$data_str)

  # find the numeric columns
  numerics <- sapply(.NNTable$data_str, is.numeric)
  numerics_table <- numerics[names(numerics) %in% unlist(.NNTable$concat$table)]

  characters <-  sapply(.NNTable$data_str, is.character)
  characters_table <- characters[names(characters) %in% unlist(.NNTable$concat$table)]

  factors <-  sapply(.NNTable$data_str, is.factor)
  factors_table <- factors[names(factors) %in% unlist(.NNTable$concat$table)]


  if (any(!(numerics | characters | factors))) {
    others <- !(numerics | characters | factors)
    .cols <- names(others)[others]
    data_str[, (.cols) := lapply(.SD, as.character), .SDcols =  .cols]

    characters <-  sapply(data_str, is.character)
    characters_table <- characters[names(characters) %in% unlist(.NNTable$concat$table)]
  }


  .cols <- names(numerics_table)[numerics_table]
  if (length(.cols))
    data_str[, (.cols) := lapply(.cols,
                                 function(name) alignLeft(Format(data_str[[name]],
                                                                 format = as.character(.NNTable$NNFormat$format[, name]))))]


  .char_cols <- names(characters_table)[characters_table]
  if (!is.null(.NNTable$grouped_columns$columns))
    .char_cols <- setdiff(.char_cols, .NNTable$grouped_columns$columns)

  if (length(.char_cols))
    data_str[, (.char_cols) := lapply(.SD,  function(x) {x[is.na(x)] <- ""; x}),
             .SDcols = .char_cols]

  if (.NNTable$NNFormat$big.mark != "" | .NNTable$NNFormat$small.mark != "") {
    data_str[, (.cols) := lapply(.SD, prettyNum,
                                 big.mark = .NNTable$NNFormat$big.mark,
                                 small.mark = .NNTable$NNFormat$small.mark,
                                 preserve.width = c("individual")),
             .SDcols = .cols]

    data_str[, (.cols) := lapply(.SD, function(x) {x[grepl("NA|NaN", x)] <- ""; x}), .SDcols = .cols]
  }


  strings <- .NNTable$concat$string

  # check for blank rows and insert
  for (i in seq_along(strings)) {
    vars <- .NNTable$concat$table[names(strings)[i]][[1]]

    non_blank <- apply(data_str[, vars, with = FALSE] != "", 1, any)

    if (!is.null(vars))
      data_str <- data_str[, (vars) := lapply(.SD, function(x)
        ifelse(x == "" & non_blank, "NA", x )), .SDcols = vars ]

    # same thing but on a data.frame
    # data_str[, vars][data_str[, vars] == "" & apply(data_str[, ..vars] != "", 1, any)] <- "NA"
  }

  # create the collapsed strings
  data_str <- cbind(data_str,
                    data.table::as.data.table(sapply(strings,
                                                     function(string) stringr::str_glue_data(data_str, string))))

  for (i in seq_along(strings)) {
    vars <- .NNTable$concat$table[names(strings)[i]][[1]]

    data_all <- apply((data_str[, vars, with = FALSE]) == "", 1, all)
    data_str <- data_str[data_all, (names(strings)[i]) := ""]

    # same for data.frame
    # data_str[data_all, names(strings)[i]] <- ""
  }

  rename <- .NNTable$columns[.NNTable$columns %in% colnames(data_str)]

  #data_str <- data.table::as.data.table(data_str)
  #
  data_str <- (data.table::setnames(data_str, old = rename, new = names(rename)))

  .NNTable$data_str <- data_str[, unique(c(names(.NNTable$columns),
                                           intersect(.NNTable$order_columns$sort_columns, colnames(data_str)))), with = FALSE]

  .NNTable$data_str <- as.data.frame(.NNTable$data_str)

  # If any of the order variables are numeric and used in the table
  # order_data <- .NNTable$data[, colnames(.NNTable$data) %in% .NNTable$order_columns]
  # order_numeric <- sapply(order_data, is.numeric)
  #
  # order_numeric <- order_numeric & names(order_numeric) %in% .NNTable$columns
  #
  # numeric_v <- data_str[, names(order_numeric)[order_numeric], drop = FALSE]
  # colnames(numeric_v) <- paste(colnames(numeric_v), "n", sep = ".")
  # data_str <- cbind(data_str, numeric_v)


  return(.NNTable)
}


#' Format method
#'
#' @param x The vector to format
#' @param ... additional arguments passed on
#'
#' @return The formatted vector
#' @export
#'
#' @examples
#' Format(c("ad", "chrjf"))
#' Format(c(rnorm(10, 10, 20)))
Format <- function(x, ...) {
  UseMethod("Format")
}

#' Format default
#'
#' @param x The vector to format
#' @param ... additional arguments passed on
#'
#' @return The formatted vector
#' @export
#' @rdname Format
Format.default <- function(x, ...) as.character(x)

#' Format numeric
#'
#' @param x \code{numeric} to
#' @param format The format to use
#' @param ... additional arguments passed on
#'
#' @return The formated vector
#' @export
#' @rdname Format
Format.numeric <- function(x, ..., format = guessFormat(x, dec = min(3, decimalPlaces(x)))) {
  y <- x
  y[!is.na(x)] <- sprintf(format[!is.na(x)], x[!is.na(x)])

  y[is.na(y) | grepl("NA", y) ] <- ""
  y
}



#' Format integer
#'
#' @param x \code{numeric} to
#' @param format The format to use
#' @param ... additional arguments passed on
#'
#' @return The formated vector
#' @export
#' @rdname Format
Format.integer <- function(x, ..., format = guessFormat(x, dec = min(3, decimalPlaces(x)))) {
  Format(as.numeric(x), ..., format = format)
}



#' Format an NNTable
#'
#' @param x An \code{NNTable} object
#' @param ... Not currently used
#' @param format_data A \code{data.frame} with formats to use on the tables
#' @param group_by The formatting can be grouped accoding to a column. This
#'   means that decimal places will only be aligned within each group and not
#'   the total column
#' @param dec Number of decimals to use as base
#' @param big.mark \code{character} specifying the character used to separate 1000 in a big number
#' @param small.mark \code{character} specifying the character to use to separate every 5th decimal.
#'
#' @return The NNTable with the format to be used for each value attached
#' @export
#'
#' @examples
#' \dontrun{
#' nrows <- 200
#' letters_col <- character(122)
#' for(i in 1:122)
#'   letters_col[i] <- sample(paste(sample(letters, 25, replace = TRUE), collapse = ""))
#'
#' tab <- data.frame(sex = as.character(sample(c("Female", "Male"), nrows, replace = TRUE)),
#'                   by_var = sample(c("type a", "type b"), nrows, replace = TRUE),
#'                   letter = as.character(sample(letters_col, nrows, replace = TRUE)),
#'                   n    = round(rnorm(nrows, 10, 20)),
#'                   mean = rnorm(nrows, 10, 20),
#'                   sd   = exp(rnorm(nrows, 0, 1)),
#'                   min  = rnorm(nrows, 10, 20),
#'                   max  = rnorm(nrows, 10, 20),
#'                   stringsAsFactors = FALSE)
#'
#' NNtable <- NNTable(tab, columns =  c("sex", "by_var", "letter", "n",
#'                                 "Mean (SD)" = "mean (sd)", "min ; max"))
#'
#'
#' n_form <- length(unique(tab$letter))
#' format_data <- data.frame(letter = unique(tab$letter),
#'                           n    = "%.0f",
#'                           mean = sample(c("%.1f", "%.2f"), n_form, replace  = TRUE),
#'                           sd   = sample(c("%.1f", "%.2f"), n_form, replace  = TRUE),
#'                           min  = sample(c("%.1f", "%.2f"), n_form, replace  = TRUE),
#'                           stringsAsFactors = FALSE)
#' format_data$max = format_data$min
#'
#' NNTable <- Format(NNtable, format_data = format_data)
#' }
#' @importFrom data.table ':='
#' @importFrom dplyr filter across
#' @rdname Format
Format.NNTable <- function(x, ..., format_data = NULL, group_by = NULL, dec = 3, big.mark = "", small.mark = "") {

  .NNTable <- x
  x <- data.table::as.data.table(.NNTable$data_str)

  # Get the concatination info
  concat <- .NNTable$concat
  # Get the columns that needs to be formated together
  combine <- initName(.NNTable$columns_to_long$columns)


  # find the numeric columns

  numerics <- sapply(x, is.numeric)
  numerics_table <- numerics[names(numerics) %in% unlist(concat$table)]

  # column names that are not concatinated are found
  first_cols <- sapply(concat$table, function(x) x[1])
  combine_first <- first_cols[names(first_cols) %in% combine]


  create_format_data <- function(x, keep = character(0), cols = unlist(concat$table)) {

    out_format <- data.frame(matrix(ncol = length(c(cols, keep)),
                                    nrow = nrow(x)),
                             stringsAsFactors = FALSE)


    row.names(out_format) <- NULL
    colnames(out_format) <- c(cols, keep)


    out_format[, c(cols, keep) ] <- x[, c(cols, keep), with = FALSE]

    # find the column matches as the non numeric columns in both datasets
    if (!is.null(format_data)) {
      column_match <- intersect(colnames(x)[!numerics], colnames(format_data))

      format_data_small <- format_data

      if (length(column_match)) {

        format_data_small <- format_data %>%
          filter(across(column_match, ~ .x %in% unique(unlist(as.data.frame(x)[, column_match])) | is.na(.x)))

        any_check <- nrow(format_data_small) > 0

        if (!any(is.na(unlist(format_data_small[, column_match])))) {
          l_row <- format_data_small[nrow(format_data_small), , drop = FALSE]
          l_row[] <- NA
          format_data_small <- rbind(format_data_small, l_row)
        }

      } else {
        any_check <- TRUE
      }
    }

    joint <- combine_first[combine_first %in% names(numerics_table)[numerics_table]]
    if (length(joint)) {

      if (!is.null(format_data) && any_check) {
        out_format[, joint] <-
          updatejointFormat(data = as.data.frame(x)[, c(column_match, joint)],
                            format_data_small, dec = dec, big.mark = big.mark, small.mark = small.mark)[, joint]

      } else {
        out_format[, joint] <-
          guessFormat(unlist(x[, joint, with = FALSE]), dec = dec, big.mark = big.mark, small.mark = small.mark)
      }
    }

    # find the non
    non_joint <- setdiff(names(numerics_table)[numerics_table], joint)

    if (length(non_joint)) {

      if (!is.null(format_data) && any_check) {
        out_temp <-
          updateUniFormat(data = as.data.frame(x)[, c(column_match, non_joint), drop = FALSE], format_data_small, dec = dec,
                          big.mark = big.mark, small.mark = small.mark)#[, non_joint]
        out_format[, colnames(out_temp)] <- out_temp
      } else {
        formats <- sapply(x[, non_joint, with = FALSE, drop = FALSE], function(x)
          guessFormat(x, dec = min(dec, decimalPlaces(x)), big.mark = big.mark, small.mark = small.mark))

        out_format[, non_joint] <- as.data.frame(t(formats),
                                                 stringsAsFactors = FALSE)
      }
    }

    return(out_format)
  }

  # add an ordering to ensure the same order is supplied after grouping
  x$keep_order_xy <- seq_len(nrow(x))

  if (!is.null(group_by)) {
    group <- apply(x[, group_by, drop = FALSE, with = FALSE], 1, function(x) paste(x, collapse = ""))
    data_split <- lapply(split(x = seq_len(nrow(x)), f = group, drop = FALSE), function(line) x[line, ])

    out_format <- data.table::rbindlist(lapply(data_split, create_format_data, keep = "keep_order_xy"))
  } else {
    out_format <- data.table::as.data.table(create_format_data(x, keep = "keep_order_xy"))
  }
  data.table::setorder(out_format, "keep_order_xy")
  out_format <- out_format[, keep_order_xy := NULL]

  .NNTable$NNFormat <- list(format = as.data.frame(out_format), format_data = format_data,
                            big.mark = big.mark, small.mark = big.mark, group_by = group_by)
  return(.NNTable)
}

decimalPlaces <- function(x) {
  if (is.null(x)) return(0)
  x <- x[!is.na(x)]
  if (length(x) == 0) return(0)
  if (max(abs(x - round(x))) > .Machine$double.eps^0.5) {
    decif <- function(x) {
      ifelse(length(x) == 2, nchar(x[[2]]), 0)
    }
    max(sapply(strsplit(sub('0+$', '', as.character(x)), ".", fixed = TRUE), decif))
  } else {
    return(0)
  }
}

guessFormat <- function(x, dec = min(3, max_dec), max_dec = decimalPlaces(x), big.mark = "", small.mark = "") {

  if (!length(x)) {
    return(character(0))
  }

  if (is.numeric(x)) {
    if (all(is.na(x))) return(NA)

    x <- x[!is.na(x)]

    if (small.mark != "" & dec > 0) {
      dec <- dec + floor((dec - 1) / 5)
    }

    if (big.mark != "") {
      num <- max(nchar(prettyNum(c(floor(min(x)), max(ceiling(x))), big.mark = big.mark, scientific = FALSE))) + dec
    } else {
      num <- max(nchar(prettyNum(c(floor(min(x)), max(ceiling(x))), scientific = FALSE))) + dec
    }

    if (dec > 0)
      num <- num + 1

    return(paste0("%", num, ".", dec, "f"))
  } else {
    return("string")
  }
}

split_format <- function(format) {
  fsplit <- strsplit(as.character(format), "[%.f]")
  num <- sapply(fsplit, "[", 2)
  dec <- sapply(fsplit, "[", 3)

  num[num == ""] <- 0
  dec[dec == ""] <- 0

  out <- list(num = as.numeric(num), dec = as.numeric(dec), format = as.character(format))
  out$num <- pmax(0, out$num - out$dec - 1)

  out
}


fillFormat <- function(format) {
  fsplit <- strsplit(as.character(format), "[%.f]")
  num <- sapply(fsplit, "[", 2)
  dec <- sapply(fsplit, "[", 3)

  num[num == ""] <- 0
  dec[dec == ""] <- 0

  out <- list(num = as.numeric(num), dec = as.numeric(dec))

  out$num[is.na(out$num)] <- max(out$num, na.rm = TRUE)
  out$dec[is.na(out$dec)] <- max(out$dec, na.rm = TRUE)

  out$num <- pmax(0, out$num - out$dec - 1)

  num <- out$num
  num[num == 0] <- ""
  format <- paste0("%", num, ".", out$dec, "f")
}



updatejointFormat <- function(data, format_data, dec, big.mark = "", small.mark = "") {

  # find the numeric columns
  numerics <- sapply(data, is.numeric)

  # find the column match as the non numeric column in both datasets
  column_match <- intersect(colnames(data)[!numerics], colnames(format_data))

  # get the order of the format_data
  fmt_order <- match(apply(data[, column_match, drop = FALSE],        1, paste, collapse = ""),
                     apply(format_data[, column_match, drop = FALSE], 1, paste, collapse = ""))

  # restrict to the applicable colnames
  old_format <- format_data[, intersect(colnames(data), colnames(format_data)), drop = FALSE]
  new_format <- format_data[fmt_order, intersect(colnames(data), colnames(format_data)), drop = FALSE]
  new_format[, column_match] <- data[, column_match]

  if (all(is.na(fmt_order))) {
    filled_format <- as.data.frame(lapply(rbind(old_format, new_format)[, setdiff(colnames(new_format), column_match)], fillFormat))

    new_format[, setdiff(colnames(new_format), column_match)] <-
      filled_format[-seq_len(nrow(old_format)), ]

  } else {
    new_format[, setdiff(colnames(new_format), column_match)] <-
      as.data.frame(lapply(new_format[, setdiff(colnames(new_format), column_match), drop = FALSE], fillFormat))
  }

  # Get the number of characters in front of the .
  x <- unlist(data[, numerics])
  x <- x[!is.na(x)]

  if (big.mark != "") {
    num_all <- max(nchar(prettyNum(c(floor(min(x)), max(ceiling(x))), big.mark = big.mark, scientific = FALSE)))
  } else {
    num_all <- max(nchar(prettyNum(c(floor(min(x)), max(ceiling(x))), scientific = FALSE)))
  }


  # Get the decimals for those missing
  x <- unlist(data[, numerics & !(colnames(data) %in% colnames(format_data))])
  missing_dec <- min(dec, decimalPlaces(x))

  if (small.mark != "" & missing_dec > 0) {
    missing_dec <- missing_dec + floor((missing_dec - 1) / 5)
  }


  # Get the decimals for the specified
  spec_fmt <- unique(as.character(unlist(new_format[, setdiff(colnames(new_format), column_match)])))
  spec_fmt_max <- lapply(split_format(spec_fmt), max)

  #adjusted_num <- num_all + max(missing_dec, spec_fmt_max$dec) + 1

  out_format_adj <- sapply(new_format[, setdiff(colnames(new_format), column_match), drop = FALSE],
                    function(x) split_format(x)$dec, simplify = "matrix")

  # Create the adjusted and new format data frames

  if ((is.numeric(out_format_adj) | is.character(out_format_adj)) && !is.null(names(out_format_adj))) {
    out_format_adj <- as.data.frame(t(out_format_adj))
  } else {
    out_format_adj <- as.data.frame(out_format_adj)
  }

  out_format_adj[,] <-
    sapply(out_format_adj, function(dec2) paste0("%", num_all + dec2 + ifelse(dec2 > 0, 1, 0), ".", dec2, "f"), simplify = "matrix")

    out_format_new <- data[, numerics & !(colnames(data) %in% colnames(format_data)), drop = FALSE]
  out_format_new[,] <- paste0("%",  num_all + missing_dec + ifelse(missing_dec > 0, 1, 0), ".", missing_dec, "f")

  # bind the created formats together
  cbind(new_format[, column_match, drop = FALSE], out_format_adj, out_format_new)[, c(column_match, names(numerics)[numerics])]
}


updateUniFormat <- function(data, format_data, dec, big.mark = "", small.mark = "") {

  # find the numeric columns
  numerics <- sapply(data, is.numeric)

  # In case we have missing format for some they are
  in_both <- intersect(colnames(data)[numerics], colnames(format_data))

  for (col in in_both)
    format_data[is.na(format_data[[col]]), col] <-
      guessFormat(data[is.na(format_data[, col]), col],
                  dec = min(dec, decimalPlaces(data[is.na(format_data[, col]), col])),
                  big.mark = big.mark, small.mark = small.mark)



  missing <- setdiff(colnames(data)[numerics], colnames(format_data))
  for (col in missing)
    format_data[, col] <-
      guessFormat(data[, col],
                  dec = min(dec, decimalPlaces(data[, col])),
                  big.mark = big.mark, small.mark = small.mark)

  #
#   if (length(missing)) {
#     mis_form <- as.data.frame(t(structure(rep(paste0("%.", dec, "f"), length(missing)), names = missing)))
#
#     if (nrow(format_data) == 1)
#       format_data <- dplyr::bind_cols(format_data, mis_form)
#     else
#       format_data <- dplyr::bind_rows(format_data, mis_form)
#   }

  # find the column match as the non numeric column in both datasets

  column_match <- intersect(colnames(data)[!numerics], colnames(format_data))

  # get the order of the format_data
  fmt_order <- match(apply(data[, column_match, drop = FALSE],        1, paste, collapse = ""),
                     apply(format_data[, column_match, drop = FALSE], 1, paste, collapse = ""))

  # in cases with no column match we will simply  dublicate the rows
  old_format <- format_data[, intersect(colnames(data), colnames(format_data)), drop = FALSE]
  new_format <- format_data[fmt_order, intersect(colnames(data), colnames(format_data)), drop = FALSE]

  new_format[, column_match] <- data[, column_match]


  if (all(is.na(fmt_order))) {
    filled_format <- as.data.frame(lapply(rbind(old_format, new_format)[,
                                                                        setdiff(colnames(new_format), column_match), drop = FALSE], fillFormat))

    new_format[, setdiff(colnames(new_format), column_match)] <-
      filled_format[-seq_len(nrow(old_format)), ]

    all.na <- sapply(new_format, function(x)  all(is.na(x)))

  } else {
    if (anyNA(format_data[, column_match])) {
      na_fmt <- format_data[is.na(format_data[[column_match]]), ][1, ]

      new_format[new_format[[column_match]] %in%
                   setdiff(new_format[[column_match]], format_data[[column_match]]),
                 setdiff(colnames(na_fmt), column_match)] <- na_fmt[, setdiff(colnames(na_fmt), column_match)]

    }

    all.na <- sapply(new_format, function(x)  all(is.na(x)))

    if (length(all.na))
      new_format[,setdiff(colnames(new_format), c(column_match, names(all.na[all.na])))] <-
        as.data.frame(lapply(
          new_format[, setdiff(colnames(new_format), c(column_match, names(all.na[all.na]))), drop = FALSE], fillFormat))
  }

  data_form <- sapply(data[, numerics, drop = FALSE], guessFormat, dec = dec, big.mark = big.mark, small.mark = small.mark)

  in_format <- colnames(new_format)[colnames(new_format) %in% names(numerics)[numerics] &
                                      !colnames(new_format) %in% names(all.na[all.na])]

  new_format[, in_format] <-
    as_tibble(sapply(in_format, function(name)
      adjustFormat(new_format[, name], data_form[name])))

  missing <- as.data.frame(t(data_form[setdiff(names(data_form) , colnames(format_data))]))
  return(cbind(new_format, missing))


}


adjustFormat <- function(format, data_format) {
  app_format  <- split_format(data_format)
  spec_format <- split_format(unlist(format))

  num <- max(app_format$num, spec_format$num) # + max(app_format$dec, spec_format$dec) + 1
  dec <- spec_format$dec

  ifelse
  paste0("%", num + ifelse(dec > 0, dec + 1, 0), ".", dec, "f")
}


