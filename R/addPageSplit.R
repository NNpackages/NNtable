#' Add grouped columns to an NNTable to form the table STUB
#'
#' @param .NNTable An \code{NNTable} generated by \code{\link{NNTable}}
#' @param keepers \code{character} with the names of the columns to keep on all pages.
#' @param cuts columns that should be moved to the following page
#' @param drop_intial_space \code{logical} When splitting a table with no keepers,
#'   should the leading space be discarded
#'
#' @return An object of class \code{NNTable} with the page split added
#'
#' @export
addPageSplit <- function(.NNTable,
                         keepers = character(0),
                         cuts  = character(0),
                         drop_intial_space = TRUE) {


  .NNTable$page_split <- list(cuts = cuts,
                              keepers = keepers,
                              drop_intial_space = drop_intial_space)

  .NNTable
}


apply_page_split_width <- function(.NNTable) {


  column_chars_list  <- get_column_chars(.NNTable)

  column.chars <- column_chars_list$column.chars

  # Remove the fake columns created in width
  if ("NNTable_pre_space" == names(column.chars)[1]) {
    column.chars[2] <- column.chars[2] + column.chars[1]
    column.chars <- column.chars[-1]
  }

  if ("NNTable_poos_space" == names(column.chars)[1]) {
    column.chars[length(column.chars) - 1] <-
      column.chars[length(column.chars) - 1] + column.chars[length(column.chars)]
    column.chars <- column.chars[-length(column.chars)]
  }

  column.chars[column.chars == 0] <- 1

  # Define the keeper columns

  keepers <- keepers_init <-
    intersect(c("NNTable_grouped_name",  .NNTable$page_split$keepers),
              names(column.chars))

  if (length(keepers_init))
    keepers <- names(column.chars)[seq_len(max(match(keepers_init,  names(column.chars)), na.rm = TRUE))]

  keeper_width <- sum(column.chars[keepers])


  # Calculate the  number of pages needed

  p_width <- .NNTable$page_size$page.width - keeper_width

  to_be_split <- names(column.chars) %in% setdiff(names(column.chars), keepers)


  # Distribute columns on the necessary pages

  list <- strsplit(names(column.chars), "__#__")
  n.header.rows <- max(sapply(list, length))



  # Create the initial header matrix
  header.mat_simple <- sapply(list, function(x) rev(c(x, rep("", n.header.rows - length(x)))))


  if (length(.NNTable$page_split$cuts)) {

    names_cuts <- .NNTable$page_split$cuts

    head_split <- header.mat_simple[, to_be_split, drop = FALSE]
    repeat_list <- list()

    for (i in seq_len(nrow(head_split))) {
      repeat_list[[i]] <- rle(head_split[i, ])
      repeat_list[[i]]$which_n <-  c(0, cumsum(repeat_list[[i]]$lengths))
    }


    cut_splits <- list()
    for (cut in names_cuts) {
      cut_splits[[cut]] <-
        lapply(repeat_list, function(compare) compare$which_n[which(cut == compare$values)])
    }

    unlist(cut_splits, use.names = FALSE)

    split_res <- list(splits = sort(unique(unlist(cut_splits, use.names = FALSE))))
    split_res$splits <- split_res$splits[split_res$splits > 0]
    pages <- length(split_res$splits) + 1
    splits <- c(0, split_res$split, sum(to_be_split))
    cols_list <- list()
    for (i in 1:(length(splits)-1))
      cols_list[[paste0("cols", i)]] <- names(column.chars)[to_be_split][(splits[i] + 1):(splits[i + 1])]

  } else {

    v <- rle(apply(header.mat_simple[, to_be_split], 2, function(x) x[x != ""][1]))

    # Find the top level different from empty

    from_to <- c(0, cumsum(v$length))

    level_chars <- numeric(0)
    for (i in seq_along(v$length))
      level_chars[i] <- sum(column.chars[to_be_split][seq(from_to[i] + 1, from_to[i + 1])])

    if (any(level_chars > p_width))
      stop("The table contain levels in the header that are wider than the total allowed width")

    counter <- 0
    max_width <- sum(column.chars)
    pages <- pages_prior <- ceiling(sum(column.chars[to_be_split]) / p_width)

    split_res <- list(splits = length(level_chars), max_width = max_width)

    #browser()

    while (max_width > p_width & counter < 3 & pages <= length(level_chars)) {

      pages <- pages_prior + counter

      split_res <- balanced.split(level_chars, pages, p_width)

      max_width <- split_res$max_width

      counter <- counter + 1
    }

    cols_list <- list()
    splits <- c(0, split_res$splits, (length(from_to) - 1))
    for (i in seq_len(pages))
      cols_list[[paste0("cols", i)]] <- names(column.chars)[to_be_split][seq(from_to[splits[i] + 1] + 1, from_to[splits[i + 1] + 1])]

  }

  .NNTable$page_split$c_pages <- pages


  # in case we do not have any keepers the initial space columns should be removed
  dropped_sep <- character(0)

  if (!length(keepers) & .NNTable$page_split$drop_intial_space) {
    drop_column <- function(x) {
      if (grepl("^sep.column.|^space.column.", x[1]))
        return(x[1])

      character(0)
    }
    dropped_sep <- unlist(lapply(cols_list, drop_column), use.names = FALSE)
  }

  # if (.NNTable$page_split$drop_intial_space) {
  #   drop_column <- function(x) {
  #     if (grepl("^sep.column.|^space.column.", x[length(x)]))
  #       return(x[length(x)])
  #
  #     character(0)
  #   }
  #
  #   dropped_sep <- c(dropped_sep,
  #                    unlist(lapply(cols_list, drop_column), use.names = FALSE))
  # }


  .NNTable$page_split$cols_list <- cols_list

  page_list <- list()
  out_list <- list()
  for (i in seq_len(pages)) {
    subtable <- .NNTable

    removed_columns <- c(unlist(cols_list[-i], use.names = FALSE), dropped_sep)

    subtable$remove$columns <- c(subtable$remove$columns, removed_columns)

    keep_cols <- match(setdiff(names(column.chars), removed_columns ), names(column.chars))

    subtable$header$matrix <- subtable$header$matrix[,keep_cols, drop = FALSE]

    if (grepl("^space.column.", unlist(cols_list[i])[1])) {
      subtable$header$matrix[, names(column.chars)[keep_cols] ==  unlist(cols_list[i])[1]] <- ""
    }

    subtable <- apply_width(subtable)

    subtable <- apply_splitPages(subtable)

    subtable <- apply_add_string_wrapping(subtable)

    if (i == 1)
      subtable$output[[1]][1] <- gsub("^\\f", "", subtable$output[[1]][1])

    page_list[[paste0("page_", i, sep = "")]]  <- subtable
    out_list[[paste0("page_", i, sep = "")]]  <- subtable$output
  }

  .NNTable$page_split$page_list <- page_list

  .NNTable$output <- unlist(do.call(mapply, c(c, out_list,  SIMPLIFY = FALSE)))

  .NNTable
}




# Matrix containing the error contribution of
# subsegments [i:j]
.makeErrorTable <- function(values) {
  cumsums = c(0, cumsum(values))
  return(outer(cumsums, cumsums, FUN='-')**2)
}

# Backtrace the optimal split points from an index matrix
.findPath <- function(index.matrix){
  nrows <- nrow(index.matrix)
  cur.idx <- ncol(index.matrix)
  path <- vector("numeric", nrows)
  for (i in nrows:1) {
    cur.idx = index.matrix[i, cur.idx]
    path[i] <- cur.idx
  }
  return(path)
}

.findSplits <- function(error.table, n.pages, p_width = Inf) {
  n.diffs <- nrow(error.table)
  max.val <- error.table[1, n.diffs]

  # Table used to backtrace the optimal path
  idx.table <- array(dim=c(n.pages-1, n.diffs))
  cur.best.splits <- error.table[1, ]
  for (i in 1:(n.pages-1)){
    cur.best.splits[cur.best.splits > p_width**2] <- Inf
    error.sums <- cur.best.splits + error.table
    idx.table[i, ] <- apply(error.sums, 2, which.min)
    cur.best.splits <- apply(error.sums, 2, min)
  }
  return(.findPath(idx.table))
}

.splitChunks <- function(values, splits) {
  #splits[1] <- max(2, splits[1])
  splits <- c(0, splits, length(values))
  chunks <- list()
  #seq(splits[i] + 1] + 1 , [splits[i + 1] + 1])
  for (i in 1:(length(splits)-1))
    chunks[[i]] <- values[(splits[i] + 1):(splits[i + 1])]
  return(chunks)
}

#' Main function that splits values into n.pages
#' chunks, minimizing sd(sum(chunk)) + I(p_width>sum(chunk)) * Inf
#' @keywords internal
balanced.split <- function(values, n.pages, p_width = Inf) {

  if (n.pages == 1)
    return(list(splits = numeric(0), max_width = sum(values)))


  if (n.pages == 2) {

    width_for <- cumsum(values)
    width_rev <- cumsum(rev(values))

    width_mat <- tibble(cuts = seq_len(length(width_for) - 1),
                        forw = width_for[-length(width_for)],
                        back = rev(width_rev[-length(width_rev)]),
                        diff_width = abs(width_for[-length(width_for)] - rev(width_rev[-length(width_rev)])),
                        max_width  = pmax(width_for[-length(width_for)], rev(width_rev[-length(width_rev)])))

    max_width <- min(width_mat$max_width)

    width_mat <- width_mat[width_mat$max_width <=  p_width, , drop = FALSE]
    splits <- width_mat$cuts[which.min(width_mat$diff_width)]
  } else {

    error.table <- .makeErrorTable(values)
    splits <- .findSplits(error.table, n.pages, p_width)

    max_width <- max(sapply(.splitChunks(values, splits), sum))
  }


  return(list(splits = splits, max_width = max_width))
}
