#' Add columns that needs to be transposed from long to wide
#'
#' @param .NNTable An \code{NNTable} generated by \code{\link{NNTable}}
#' @param ... Nested \code{list} of columns that should be transposed. For one
#'   level it can be defined as TRTA = c("N", "P", "E")xx. Nested levels are
#'   added in lists (sex = list(TRTA = c("N", "P", "E"))
#' @param add_cat_space \code{logical} indicating if a category spacer should be
#'   added
#' @param fun.aggregate \code{function} if more than one value is present in
#'   data for each grouping this function will be used to summarise
#' @param .remove_last_header_row \code{logical} indicating if the last header
#'   row should be removed in case only one sublevel is present for each column
#' @param .remove_empty_columns \code{logical} indicating if created columns
#'   that are completely empty should be removed.
#' @param .remove_empty_level \code{integer} indicating the level from which
#'   empty nested columns are removed. A value of 1 indicates that all empty
#'   columns should be removed. A value of 2 indicates that all columns in level
#'   1 should be empty before the columns are removed.
#'
#' @return An object of class \code{NNTable} with the transpose specified
#'
#' @examples
#'
#' ## *****************************************************************************
#' ## # Example of transpose from wide to long                                 ----
#' ##
#' ## Calculate the statistics for an AE table
#' ## *****************************************************************************
#'
#' library(dplyr)
#' #library(NNR)
#'
#' # Filter data according Safety analysis set
#' adsl_f <- adsl            %>%
#'   filter(SAFFL == "Y")    %>%
#'     rename(TRTA = TRT01P)
#'
#' # Calculate total exposure
#' totals <- adsl_f        %>%
#'   group_by(TRTA)        %>%
#'   summarize("Number of subjects"     = n_distinct(USUBJID),
#'             "Total exposure (years)" = sum(TR01DURY))
#'
#' # Calculate adverse event statistics
#' output <- adae %>% group_by(AEBODSYS, AEDECOD, TRTA) %>%
#'   dplyr::summarise(N = n_distinct(USUBJID),
#'                    P = N / nrow(adsl),
#'                    E = n())
#'
#' # Generate the NNTable ------------------------------------------------------
#'
#' # Initiate by defining the columns based on ADAE
#' .NNTable <- NNTable(output, "AEBODSYS", "AEDECOD", "TRTA", "N", "(%)" = "(P)", "E")
#'
#' # Add exposure calculated from ADSL
#' .NNTable <- .NNTable %>%
#'   addExposure(exposure = totals,
#'               format_alone = FALSE,
#'               format_data  = c("Number of subjects"     = "%.0f",
#'                                "Total exposure (years)" = "%.2f"))
#'
#' # Transpose to wide
#' .NNTable <- .NNTable %>% addTransWide(TRTA = c("N", "(%)", "E"))
#'
#' # Add Filling such that non-observed events is assigned 0
#' .NNTable <- .NNTable %>% addFilling(N = 0)
#'
#' # Add formatting information for the table
#' .NNTable <- .NNTable %>% addFormat(format_data = c(N = "%.0f", P = "%.2f", E = "%.0f"))
#'
#' # Group the columns AEBODSYS and AEDECOD
#' .NNTable <- .NNTable %>% addGroupedColumns("AEBODSYS", "AEDECOD" , name = "some name")
#'
#' # Truncate columns at a certain width such that long names appear on multiple lines
#' .NNTable <- .NNTable %>% addTruncation(AEBODSYS = 50, AEDECOD = 48)
#'
#' # View the final result
#' .NNTable
#'
#' ## *****************************************************************************
#' ## # Example of transpose from with newsted columns                         ----
#' ##
#' ## Calculate the statistics for an AE table grouped by age group
#' ## *****************************************************************************
#' # create summary
#' output <- adae %>% group_by(AGEGR2, AEBODSYS, AEDECOD, TRTA) %>%
#'   dplyr::summarise(N = n_distinct(USUBJID),
#'                    P = N / nrow(adsl) * 100,
#'                    E = n())
#'
#' # create the NNTable
#' .NNTable <- NNTable(output, "AGEGR2", "AEBODSYS", "AEDECOD", "TRTA", "N", "(%)" = "(P)", "E") %>%
#'   addTransWide(AGEGR2 = list(TRTA = c("N", "(%)", "E"))) %>%
#'   addFilling(N = 0) %>%
#'   addGroupedColumns("AEBODSYS", "AEDECOD") %>%
#'   addTruncation(AEBODSYS = 32, AEDECOD = "30") %>%
#'   addOrder(N = -1)
#'
#' .NNTable
#'
#' # change the order of the transpose
#' .NNTable %>% addTransWide(TRTA = list(AGEGR2 = c("N", "(%)", "E")))
#'
#' @export
addTransWide <- function(.NNTable, ..., .remove_last_header_row = TRUE,
                         .remove_empty_columns = TRUE,
                         .remove_empty_level = 1,
                         add_cat_space = TRUE, fun.aggregate = function(x) gsub("[0-9]", "x", x[1])) {
  columns <- list(...)
  .NNTable$columns_to_wide <- list(columns = columns, add_cat_space = add_cat_space,
                                   fun.aggregate = fun.aggregate,
                                   .remove_last_header_row = .remove_last_header_row,
                                   .remove_empty_columns = .remove_empty_columns,
                                   .remove_empty_level = .remove_empty_level)

  return(.NNTable)
}

#' @importFrom data.table dcast as.data.table
#' @importFrom stats formula
apply_tranToWide <- function(.NNTable) {

  # Extract the data
  data <- data.table::as.data.table(.NNTable$data_str)

  # Get the call
  columns_to_wide_1 <- .NNTable$columns_to_wide$columns


  translate <- function(x) {

    out <- x
    for (i in seq_along(x)) {
      if (is.recursive(x[[i]])) {
        out[[i]] <- translate(x[[i]])
      } else {

        miss <- setdiff(x[[i]], colnames(data))

        if (length(miss)) {
          orig <- intersect(x[[i]], names(.NNTable$columns_attr$columns_tree[miss]))
          new  <- intersect(x[[i]], colnames(data))
          out[[i]] <- c(unlist(.NNTable$columns_attr$columns_tree[orig]), new)
          names(out[[i]]) <- NULL
        } else {
          out[[i]] <- x[[i]]
        }
      }
    }

    out
  }

  columns_to_wide <- translate(x = columns_to_wide_1)


  data$totally_stable_column <- "TESTER"

  getListLevel <- function(x, level = 2) {
    for (i in seq_len(level))
      x <- x[[1]]
    return(x)
  }

  varnames <- #gsub("#", "NNable_square",
    initName(columns_to_wide)#)

  data_out <- data

  if (.NNTable$columns_to_wide$add_cat_space) {
    data_out$space.column.1 <- ""
    data_out$space.column.2 <- ""
    varnames = c("space.column.1", varnames, "space.column.2")
  }

  sequence <-  rev(seq_len(depth(columns_to_wide)) - 1)


  #colnames(data_out) <- gsub("#", "NNable_square", colnames(data_out))

  for (i in sequence) {

    columns_to_wide.i <- getListLevel(columns_to_wide, i)
    #columns_to_wide.i <- gsub("#", "NNable_square", columns_to_wide.i)
    stable.vars <- setdiff(colnames(data_out), c(names(columns_to_wide.i), varnames))


    comb <- data.table::dcast(data_out,
                              formula(paste(paste0("`", stable.vars, "`", collapse = " + " ), " ~ ",
                                            paste0("`", names(columns_to_wide.i)[1], "`"), collapse = "")),
                              value.var = varnames, fill = "", #fun.aggregate = .NNTable$columns_to_wide$fun.aggregate,
                              sep = "__#__")


    if (is.factor(data[[names(columns_to_wide.i)[1]]])) {
      f <- levels(data[[names(columns_to_wide.i)[1]]])
      f <- f[f %in% as.character(data[[names(columns_to_wide.i)[1]]])]
    } else {
      f <- sort(unique(data[[names(columns_to_wide.i)[1]]]))
    }

    varnames <- paste(rep(varnames, length(f)  ), rep(f, each = length(varnames)), sep = "__#__")

    cols <- c(stable.vars, varnames)
    data_out <- comb[, cols,  with = FALSE]
  }


  data_out <- data_out[, !"totally_stable_column"]

  # find space columns
  if (.NNTable$columns_to_wide$.remove_empty_columns) {
    spacers.l <- grepl("^space.column.", cols)

    acc_cols <- setdiff(cols[!spacers.l], stable.vars)

    all_empty <-
      apply(data_out[, acc_cols, with = FALSE] == "", 2, all)

    if (any(all_empty)) {
      acc_empty_names <- names(all_empty)[all_empty]

      if (.NNTable$columns_to_wide$.remove_empty_level == 1) {
        which <- match(acc_empty_names, cols)
        data_out[, (cols[unique(c(which - 1, which, which + 1))]) := NULL]
      } else {
        remove_cols <- character(0)

        empty_col_split <- strsplit(acc_empty_names, "__#__")

        max_depth <- max(sapply(empty_col_split, length))

        if (max_depth >= .NNTable$columns_to_wide$.remove_empty_level) {
          for (i in max_depth:.NNTable$columns_to_wide$.remove_empty_level) {
            uniq_level <- unique(sapply(empty_col_split, function(x) {
              paste0(x[min(i, length(x)):length(x)], collapse = "__#__")}))

            for (level in uniq_level) {

              cols_2 <- acc_cols[stringr::str_detect(acc_cols, stringr::fixed(paste0("__#__", level)))]


              if (length(cols_2) > 0 && all(cols_2 %in% acc_empty_names)) {
                remove_cols <- c(remove_cols, cols_2)
              }
            }
          }

          remove_cols2 <- unique(remove_cols)

          which <- match(remove_cols2, cols)
          data_out[, (cols[unique(c(which - 1, which, which + 1))]) := NULL]
        }
      }


    }
  }

  # Remove unwanted spacers
  spacers   <- grep("^space.column.", colnames(data_out))

  dup.spacers <- spacers[diff(spacers) == 1]

  if (max(spacers) == ncol(data_out))
    dup.spacers <- c(dup.spacers, ncol(data_out))

  first <- grep("^NNTable_sort", colnames(data_out), invert = TRUE)[1]

  if (min(spacers) == first)
    dup.spacers <- c(first, dup.spacers)

  .NNTable$data_str <- as.data.frame(data_out[, (dup.spacers) := NULL])


  return(.NNTable)
}

