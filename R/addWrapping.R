#' Add wrapping to an NNTable
#'
#' @param .NNTable An \code{NNTable} generated by \code{\link{NNTable}}
#' @param title \code{character} with the title
#' @param footnote \code{character} with the footnote
#' @param sys_footnote \code{character} with the system footnote
#' @param title_space \code{character} to be added between the title and
#'   and table header
#' @param footer_space \code{character} to be added between the footnote and
#'   sys_footnote.
#'
#' @return An object of class \code{NNTable} with the wrapping specified
#' @export
#'
#' @importFrom stringi stri_wrap
#' @examples
#'
#' ## *****************************************************************************
#' ## # Example of transpose from wide to long                                 ----
#' ##
#' ## Calculate the statistics for an AE table
#' ## *****************************************************************************
#'
#' library(dplyr)
#' # library(NNR)
#'
#' # Filter data according Safety analysis set
#' adsl_f <- adsl            %>%
#'   filter(SAFFL == "Y")    %>%
#'     rename(TRTA = TRT01P)
#'
#' # Calculate total exposure
#' totals <- adsl_f        %>%
#'   group_by(TRTA)        %>%
#'   summarize("Number of subjects"     = n_distinct(USUBJID),
#'             "Total exposure (years)" = sum(TR01DURY))
#'
#' # Calculate adverse event statistics
#' output <- adae %>% group_by(AEBODSYS, AEDECOD, TRTA) %>%
#'   dplyr::summarise(N = n_distinct(USUBJID),
#'                    P = N / nrow(adsl),
#'                    E = n())
#'
#' # Generate the NNTable ------------------------------------------------------
#'
#' # Initiate by defining the columns based on ADAE
#' .NNTable <- NNTable(output, "AEBODSYS", "AEDECOD", "TRTA", "N", "(%)" = "(P)", "E") %>%
#'             addTruncation(AEBODSYS = 50, AEDECOD = 48)                              %>%
#'             addGroupedColumns("AEBODSYS", "AEDECOD" , name = "some name")
#'
#' # Add the title and footnote, these can span several lines and will
#' #  automatically be wrapped
#' .NNTable <- .NNTable %>%
#'             addWrapping(title        = "This could be a very long title",
#'                         footnote     = "This could be a very long footnote",
#'                         sys_footnote = "Explain where the data comes from")
#'
#' # View the final result
#' .NNTable
addWrapping <- function(.NNTable, title, footnote, sys_footnote, title_space = "", footer_space = "") {

  width <- .NNTable$page_size$page.width

  # Add the title
  title <- stringi::stri_wrap(title, width = width, simplify = TRUE)
  title <- c(title, title_space)

  footer <- stringi::stri_wrap(footnote, width = width, simplify = TRUE)
  footer <- c(footer, footer_space)

  sys_footnote <- stringi::stri_wrap(sys_footnote, width = width, simplify = TRUE)

  .NNTable$wrapping <- list(title = title, footer = footer, sys_footnote = sys_footnote)

  return(.NNTable)
}


#' @importFrom Matrix t
apply_createHeader <- function(.NNTable) {

  data_str <- .NNTable$data_str[, setdiff(colnames(.NNTable$data_str),
                                          c(.NNTable$remove$columns, .NNTable$remove$columns_trunc)), drop = FALSE]

  # Remove the added _trunc from the colnames
  colnames(data_str)[grep("_trunc$", colnames(data_str))] <-
    gsub("_trunc$", "", colnames(data_str)[grep("_trunc$", colnames(data_str))])

  # Get the number of columns
  ncol <- ncol(data_str)

  # Find the number of characters in the header
  rep_name = ""
  if (!is.null(.NNTable$grouped_columns$name))
    rep_name = .NNTable$grouped_columns$name
  list <- strsplit(gsub("NNTable_grouped_name", rep_name , colnames(data_str)), "__#__")
  n.header.rows <- max(sapply(list, length))

  # create the initial header matrix
  header.mat <- sapply(list, function(x) rev(c(x, rep("", n.header.rows - length(x)))))

  if (!is.matrix(header.mat)) {
    header.mat <- as.matrix(t(header.mat))
  }

  # find the columns_to_wide spacers and rename to blank
  spacers <- grep("^space.column.|^sep.column", colnames(data_str))
  prev.space <- FALSE

  for (i in seq_len(nrow(header.mat))) {
    if (i > 1) prev.space <- header.mat[i - 1, spacers - 1] != header.mat[i - 1, spacers + 1]
    header.mat[i, spacers[header.mat[i, spacers - 1] != header.mat[i, spacers + 1] | prev.space ]] <- ""
  }

  header_last_row <- header.mat[i, ]

  # clear last row if only one repeat is present for the second to last row
  if (i > 1 && length(.NNTable$columns_to_wide) > 0 && .NNTable$columns_to_wide$.remove_last_header_row) {
    if (max(rle(header.mat[ i - 1  , header.mat[ i - 1, ] != ""])$lengths) == 1) {
      header.mat[i, header.mat[ i - 1, ] != ""] <- ""

      if (all(header.mat[i - 1, header.mat[ i, ] != ""] == "")) {
        header.mat[i - 1, header.mat[ i, ] != ""] <- header.mat[i, header.mat[ i, ] != ""]
        header.mat <- header.mat[-i, ]
      }
    }
  }

  if (!is.matrix(header.mat)) {
    header.mat <- as.matrix(t(header.mat))
  }

  # remove header name for the long format column
  if (!is.null(.NNTable$columns_to_long) && length(.NNTable$columns_to_long)) {
    header.mat[header.mat == .NNTable$columns_to_long$var_name ] <-
      .NNTable$columns_to_long$display_name
  }


  ### split the header matrix into more rows in accordance with split
  if (!is.null(.NNTable$cell_split)) {

    if (.NNTable$cell_split$align %in% c("bottom", "centre")) {

      header.mat_pre <- header.mat

      n_new_lines <-
        matrix(sapply(gregexpr(.NNTable$cell_split$split, header.mat),
                      function(x) sum(x > 0)), nrow = nrow(header.mat), byrow = FALSE)



      if (.NNTable$cell_split$align == "centre") {
        n_new_lines
        n_missing_lines <- apply(n_new_lines, 1, max) - n_new_lines
        n_left_splits <- ceiling(n_missing_lines / 2)
        n_right_splits <- n_missing_lines - n_left_splits

        left_splits <- sapply(c(Matrix::t(n_left_splits)),
                              function(n) paste(rep(gsub("\\\\", "", .NNTable$cell_split$split), n),
                                                collapse = ""))

        right_splits <- sapply(c(Matrix::t(n_right_splits)),
                               function(n) paste(rep(gsub("\\\\", "", .NNTable$cell_split$split), n),
                                                 collapse = ""))

      } else {
        left_splits <- sapply(c(Matrix::t(apply(n_new_lines, 1, max) - n_new_lines)),
                              function(n) paste(rep(gsub("\\\\", "", .NNTable$cell_split$split), n),
                                                collapse = ""))

        right_splits <- rep("", length(left_splits))
      }

      header.mat <- data.table::as.data.table(
        matrix(paste0(left_splits, c(Matrix::t(header.mat)), right_splits),
               nrow = nrow(header.mat), byrow = TRUE))


      header.mat[header.mat_pre == ""] <- ""

    }


    header.mat <- data.table::as.data.table(header.mat)

    # header.mat[header.mat == gsub("\\\\", "", .NNTable$cell_split$split)] <- ""

    X <- lapply(header.mat, strsplit , split = .NNTable$cell_split$split)

    repeats <-
      apply(as.data.frame(lapply(X, function(x) vapply(x, length, 1L))), 1, max)

    repeats <- rep(seq_along(repeats), repeats)

    SetUp <- lapply(X, function(x) {
      A <- vapply(x, length, 1L)
      list(Mat = cbind(rep(seq_along(A), A), sequence(A)),
           Val = unlist(x))
    })

    Ncol <- max(unlist(lapply(SetUp, function(y)
      y[["Mat"]][, 2]), use.names = FALSE))

    X <- lapply(seq_along(SetUp), function(y) {
      M <- matrix("Inserted Blank", nrow = nrow(header.mat), ncol = Ncol)
      M[SetUp[[y]][["Mat"]]] <- SetUp[[y]][["Val"]]
      M
    })

    indt <- header.mat[rep(sequence(nrow(header.mat)), each = Ncol)]

    X <- lapply(X, function(y) as.vector(t(y)))

    split_cols <- colnames(header.mat)
    indt[, (split_cols) := lapply(X, unlist, use.names = FALSE)][]

    indt <- indt[!apply(indt[, split_cols, with = FALSE] == "Inserted Blank", 1, all), ]

    indt <- indt[, (split_cols) := lapply(.SD, function(x)
      ifelse(x == "Inserted Blank", "", x)), .SDcols = split_cols]


    header.mat <- as.matrix(indt)
  } else {
    repeats <- seq_len(nrow(header.mat))
  }
  ###

  if (!is.null(.NNTable$header)) {
    .NNTable$header$matrix <- header.mat
    .NNTable$header$repeats <- repeats
  } else {
    .NNTable$header <- list(matrix = header.mat, underscore = FALSE,
                            repeats = repeats)

  }

  return(.NNTable)
}

